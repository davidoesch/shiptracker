<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schiffs-Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        .ship-popup {
            font-size: 14px;
            line-height: 1.4;
        }

        .ship-popup strong {
            color: #2c5aa0;
        }

        .status-info {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .error-message {
            color: red;
            font-weight: bold;
        }
    </style>
</head>

<body>
    <div id="loading">Lade Schiffsdaten...</div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Navigationsstatus-Mapping
        const navigationStatus = {
            0: "Unter Verwendung der Maschine",
            1: "Vor Anker",
            2: "Manövrierunfähig",
            3: "Manövriereingeschränkt",
            4: "Beeinträchtigt durch Tiefgang",
            5: "Festgemacht",
            6: "Auf Grund gelaufen",
            7: "Fischfang",
            8: "Unter Segel",
            9: "Reserviert für HSC",
            10: "Reserviert für WIG",
            11: "Reserviert für zukünftige Nutzung",
            12: "Reserviert für zukünftige Nutzung",
            13: "Reserviert für zukünftige Nutzung",
            14: "AIS-SART aktiv",
            15: "Nicht verfügbar"
        };

        // Funktion zum Berechnen der Zeit seit dem letzten Update
        function getTimeSinceUpdate(utcTimeString) {
            try {
                // Parse ISO 8601 format with timezone
                const updateTime = new Date(utcTimeString);
                const now = new Date();
                const diffMs = now - updateTime;

                // Convert to appropriate time unit
                const diffSeconds = Math.floor(diffMs / 1000);
                const diffMinutes = Math.floor(diffSeconds / 60);
                const diffHours = Math.floor(diffMinutes / 60);
                const diffDays = Math.floor(diffHours / 24);

                if (diffDays > 0) {
                    return `${diffDays} Tag${diffDays !== 1 ? 'en' : ''}`;
                } else if (diffHours > 0) {
                    return `${diffHours} Stunde${diffHours !== 1 ? 'n' : ''}`;
                } else if (diffMinutes > 0) {
                    return `${diffMinutes} Minute${diffMinutes !== 1 ? 'n' : ''}`;
                } else {
                    return `${diffSeconds} Sekunde${diffSeconds !== 1 ? 'n' : ''}`;
                }
            } catch (error) {
                console.error('Error parsing timestamp:', error);
                return 'unbekannt';
            }
        }

        // Funktion zum Bestimmen der Schiffsfarbe
        function getShipColor(navStatus, cog, sog) {
            // Grün wenn unterwegs (nicht vor Anker, Kurs verfügbar, Geschwindigkeit > 0)
            if (navStatus !== 1 && cog !== 360 && sog > 0) {
                return '#28a745'; // Grün
            }
            return '#fd7e14'; // Orange
        }



        // Funktion zum Erstellen eines Schiffs-SVG-Icons
        function createShipIcon(cog, color, isMoving) {
            let svgIcon;

            if (!isMoving) {
                // Kreis für gestopptes Schiff
                svgIcon = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="10" fill="${color}" stroke="#000" stroke-width="2"/>
                    </svg>
                `;

                return L.divIcon({
                    html: svgIcon,
                    className: 'ship-icon',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12],
                    popupAnchor: [0, -12]
                });
            } else if (cog === 370) {
                // Kreis für fahrendes Schiff ohne Kurs-Info (grün)
                svgIcon = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="10" fill="#28a745" stroke="#000" stroke-width="2"/>
                    </svg>
                `;

                return L.divIcon({
                    html: svgIcon,
                    className: 'ship-icon',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12],
                    popupAnchor: [0, -12]
                });
            } else {
                // Pfeil für fahrendes Schiff mit Kurs-Info
                const rotation = cog === 360 ? 0 : cog;

                svgIcon = `
                    <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="46" height="46" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect width="48" height="48" fill="white" fill-opacity="0.01"/>
                        <g transform="rotate(${rotation - 45} 24 24)" fill="${color}" stroke="#000" stroke-width="1">
                            <path d="M42 6L4 20.1383L24 24.0083L29.0052 44L42 6Z"/>
                        </g>
                    </svg>
                `;

                return L.divIcon({
                    html: svgIcon,
                    className: 'ship-icon',
                    iconSize: [46, 46],
                    iconAnchor: [23, 23],
                    popupAnchor: [0, -23]
                });
            }
        }

        // Funktion zum Laden der Schiffsdaten vom Server
        async function loadShipData() {
            try {
                const response = await fetch('position_report.json');
                if (!response.ok) {
                    throw new Error(`HTTP-Fehler! Status: ${response.status}`);
                }
                const shipData = await response.json();
                return shipData;
            } catch (error) {
                console.error('Fehler beim Laden der Schiffsdaten:', error);
                throw error;
            }
        }

        // Funktion zum Laden der Schiffsspuren
        async function loadShipTracks() {
            try {
                const response = await fetch('ship_tracks.geojson');
                if (!response.ok) {
                    console.warn('Schiffsspuren-Datei nicht gefunden oder nicht erreichbar');
                    return null;
                }
                const tracksData = await response.json();
                return tracksData;
            } catch (error) {
                console.warn('Fehler beim Laden der Schiffsspuren:', error);
                return null;
            }
        }

        // Funktion zum Laden der Schiffspositionen
        async function loadShipPositions() {
            try {
                const response = await fetch('ship_position.geojson');
                if (!response.ok) {
                    console.warn('Schiffspositionen-Datei nicht gefunden oder nicht erreichbar');
                    return null;
                }
                const positionsData = await response.json();
                return positionsData;
            } catch (error) {
                console.warn('Fehler beim Laden der Schiffspositionen:', error);
                return null;
            }
        }

        // Globale Variablen für Karte und Layer
        let map;
        let shipMarker;
        let trackLayers = [];
        let infoControl;
        let currentShipData = null;
        let esriImagery, esriLabels, osmPositron;
        let currentBasemap = 'satellite'; // 'satellite' or 'osm'
        let positionMarkers = [];
        let positionsData = null;

        // Funktion zum Parsen der URL-Parameter
        function getUrlParameters() {
            const params = new URLSearchParams(window.location.search);
            return {
                popupzoom: params.get('popupzoom') !== 'false', // default true
                zoom: parseInt(params.get('zoom')) || 5, // default 5
                map: params.get('map') || 'satellite' // 'satellite' or 'osm'
            };
        }

        // URL-Parameter einmal beim Laden auslesen
        const urlParams = getUrlParameters();

        // Funktion zur Konvertierung von Windgeschwindigkeit (km/h) in Beaufort-Skala
        function getBeaufortScale(windSpeedKmh) {
            if (windSpeedKmh < 1) return "0 (Windstille)";
            if (windSpeedKmh < 5) return "1 (Leiser Zug)";
            if (windSpeedKmh < 11) return "2 (Leichte Brise)";
            if (windSpeedKmh < 19) return "3 (Schwache Brise)";
            if (windSpeedKmh < 28) return "4 (Mäßige Brise)";
            if (windSpeedKmh < 38) return "5 (Frische Brise)";
            if (windSpeedKmh < 49) return "6 (Starker Wind)";
            if (windSpeedKmh < 61) return "7 (Steifer Wind)";
            if (windSpeedKmh < 74) return "8 (Stürmischer Wind)";
            if (windSpeedKmh < 88) return "9 (Sturm)";
            if (windSpeedKmh < 102) return "10 (Schwerer Sturm)";
            if (windSpeedKmh < 117) return "11 (Orkanartiger Sturm)";
            return "12 (Orkan)";
        }

        // Funktion zur Berechnung der Distanz zwischen zwei Koordinaten in Seemeilen
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3440.065; // Erdradius in Seemeilen (nautical miles)
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Funktion zur Berechnung der Gesamtlänge eines Tracks in Seemeilen
        function calculateTrackLength(coordinates) {
            let totalDistance = 0;
            for (let i = 1; i < coordinates.length; i++) {
                const [lon1, lat1] = coordinates[i - 1];
                const [lon2, lat2] = coordinates[i];
                totalDistance += calculateDistance(lat1, lon1, lat2, lon2);
            }
            return Math.round(totalDistance * 10) / 10; // Auf eine Dezimalstelle runden
        }

        // --- START: FUNKTIONEN IN GLOBALEN SCOPE VERSCHOBEN ---

        // Funktion zum Anzeigen/Ausblenden der Positionsmarker basierend auf Zoom-Level
        function updatePositionMarkersVisibility() {
            if (!map) return; // Sicherstellen, dass die Karte initialisiert ist
            const currentZoom = map.getZoom();
            const shouldShow = currentZoom >= 6 && currentZoom <= 22;

            positionMarkers.forEach(marker => {
                if (shouldShow) {
                    if (!map.hasLayer(marker)) {
                        marker.addTo(map);
                    }
                } else {
                    if (map.hasLayer(marker)) {
                        map.removeLayer(marker);
                    }
                }
            });
        }

        // Funktion zum Laden und Anzeigen der Schiffspositionen
        async function loadAndDisplayPositions() {
            // --- NEU: Alte Positions-Marker entfernen ---
            if (positionMarkers.length > 0) {
                positionMarkers.forEach(marker => {
                    if (map.hasLayer(marker)) {
                        map.removeLayer(marker);
                    }
                });
                positionMarkers = []; // Array zurücksetzen
            }
            // --- Ende NEU ---

            try {
                positionsData = await loadShipPositions();

                if (positionsData && positionsData.features) {
                    positionsData.features.forEach(feature => {
                        if (feature.geometry && feature.geometry.type === 'Point') {
                            const coords = feature.geometry.coordinates;
                            const props = feature.properties;

                            // Roten Kreis-Marker erstellen
                            const positionIcon = L.divIcon({
                                html: `
                                    <div style="position: relative;">
                                        <svg width="12" height="12" style="display: block;">
                                            <circle cx="6" cy="6" r="5" fill="red" stroke="white" stroke-width="1"/>
                                        </svg>
                                        <div style="position: absolute; left: 14px; top: -4px; white-space: nowrap; font-size: 11px; font-weight: bold; color: red; text-shadow: -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white, 1px 1px 0 white;">${props.date}</div>
                                    </div>
                                `,
                                className: 'position-marker',
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            });

                            // Marker erstellen (GeoJSON verwendet [lon, lat], Leaflet verwendet [lat, lon])
                            const marker = L.marker([coords[1], coords[0]], {
                                icon: positionIcon
                            });

                            positionMarkers.push(marker);
                        }
                    });

                    // Initial visibility basierend auf aktuellem Zoom
                    updatePositionMarkersVisibility();
                }
            } catch (error) {
                console.warn('Schiffspositionen konnten nicht geladen werden:', error);
            }
        }

        // --- ENDE: FUNKTIONEN IN GLOBALEN SCOPE VERSCHOBEN ---


        // Funktion zum Laden und Anzeigen der Schiffsspuren
        async function loadAndDisplayTracks() {
            // --- NEU: Alte Track-Layer entfernen ---
            if (trackLayers.length > 0) {
                trackLayers.forEach(layer => {
                    if (map.hasLayer(layer)) {
                        map.removeLayer(layer);
                    }
                });
                trackLayers = []; // Array zurücksetzen
            }
            // --- Ende NEU ---

            try {
                const tracksData = await loadShipTracks();

                // Schiffsspuren zur Karte hinzufügen (falls geladen)
                if (tracksData && tracksData.features) {
                    tracksData.features.forEach(feature => {
                        if (feature.geometry && feature.geometry.type === 'LineString') {
                            // Koordinaten von GeoJSON [lon, lat] zu Leaflet [lat, lon] konvertieren
                            const coordinates = feature.geometry.coordinates.map(coord => [coord[1], coord[0]]);

                            // Track-Informationen aus Properties extrahieren
                            const trackInfo = feature.properties;
                            const startTime = new Date(trackInfo.start_time).toLocaleDateString('de-DE');
                            const endTime = new Date(trackInfo.end_time).toLocaleDateString('de-DE');


                            // Länge der Fahrtroute in Seemeilen berechnen
                            const trackLength = calculateTrackLength(feature.geometry.coordinates);

                            // Weiße Linie für die Fahrtroute erstellen
                            const trackLine = L.polyline(coordinates, {
                                color: 'red',
                                weight: 3,
                                opacity: 0.8,
                                dashArray: '5, 5' // Optional: gestrichelte Linie
                            }).addTo(map);

                            // Popup für die Fahrtroute
                            const trackPopupContent = `
                                <div class="ship-popup">
                                    <h4 style="margin-top:0; color:#2c5aa0;">Fahrtroute</h4>                                   
                                    <strong>Startzeit:</strong> ${startTime}<br>
                                    <strong>Endzeit:</strong> ${endTime}<br>
                                    <strong>Länge:</strong> ${trackLength} Seemeilen<br>
                                </div>
                            `;

                            trackLine.bindPopup(trackPopupContent);

                            // Track-Layer speichern für spätere Updates
                            trackLayers.push(trackLine);
                        }
                    });
                }
            } catch (error) {
                console.warn('Schiffsspuren konnten nicht geladen werden:', error);
            }
        }


        // Funktion zur Karteninitialisierung (nur einmal aufgerufen)
        async function initializeMap() {
            try {
                // Schiffsdaten laden
                currentShipData = await loadShipData();
                const posReport = currentShipData.PositionReport;

                // Loading-Nachricht entfernen
                document.getElementById('loading').style.display = 'none';

                // Karte initialisieren und auf Schiffsposition zentrieren
                map = L.map('map', {
                    zoomControl: urlParams.popupzoom // Zoom-Controls basierend auf URL-Parameter
                }).setView([posReport.Latitude, posReport.Longitude], urlParams.zoom);

                // Basiskarten definieren
                // Esri Satellite Imagery
                esriImagery = L.tileLayer(
                    'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Tiles &copy; Esri, Maxar, Earthstar Geographics',
                    maxZoom: 19
                }
                );

                // Esri Labels overlay (boundaries, roads, places)
                esriLabels = L.tileLayer(
                    'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
                    attribution: 'Labels &copy; Esri',
                    maxZoom: 19
                }
                );

                // OpenStreetMap POSITRON
                osmPositron = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {

                    subdomains: 'abcd',
                    maxZoom: 19
                });

                // Basiskarte basierend auf URL-Parameter setzen
                currentBasemap = urlParams.map;
                if (currentBasemap === 'osm') {
                    osmPositron.addTo(map);
                } else {
                    esriImagery.addTo(map);
                    esriLabels.addTo(map);
                }

                // Schiffsspuren laden und anzeigen
                await loadAndDisplayTracks();

                // Schiffspositionen laden und anzeigen
                await loadAndDisplayPositions();

                // --- NEU: Event-Listener HIER EINMALIG setzen ---
                // (Die Funktionen selbst sind jetzt global)
                map.on('zoomend', updatePositionMarkersVisibility);


                // Schiffsdaten initial anzeigen
                updateShipDisplay();

            } catch (error) {
                console.error('Fehler beim Initialisieren der Karte:', error);
                document.getElementById('loading').innerHTML = `
                    <div class="error-message">
                        Fehler beim Laden der Schiffsdaten:<br>
                        ${error.message}<br><br>
                        Bitte prüfen Sie, ob die Datei 'position_report.json' auf dem Server verfügbar ist.
                    </div>
                `;
            }
        }

        // Funktion zum Aktualisieren der Schiffsdaten (lädt neue Daten vom Server)
        async function updateShipData() {
            try {
                // --- NEU: Auch Tracks und Positionen neu laden ---
                await loadAndDisplayTracks();
                await loadAndDisplayPositions();
                // --- Ende NEU ---

                currentShipData = await loadShipData();
                updateShipDisplay();
            } catch (error) {
                console.error('Fehler beim Aktualisieren der Schiffsdaten:', error);
                // Bei Fehlern die letzten bekannten Daten beibehalten
            }
        }

        // Funktion zum Anzeigen der Schiffsdaten auf der Karte
        function updateShipDisplay() {
            try {
                if (!currentShipData) {
                    console.warn('Keine Schiffsdaten verfügbar');
                    return;
                }

                const posReport = currentShipData.PositionReport;
                const metaData = currentShipData.MetaData;
                const weatherData = currentShipData.WeatherData;


                // Status bestimmen
                const statusText = navigationStatus[posReport.NavigationalStatus] || "Unbekannt";
                const isMoving = posReport.NavigationalStatus !== 1 && posReport.Cog !== 360 && posReport.Sog > 0;
                const currentStatus = isMoving ? "Unterwegs" : "Gestoppt/Vor Anker";

                // Schiffsfarbe bestimmen
                const shipColor = getShipColor(posReport.NavigationalStatus, posReport.Cog, posReport.Sog);

                // Schiffs-Icon erstellen - Verwende COG (Course over Ground) für die Rotation
                const shipIcon = createShipIcon(posReport.Cog, shipColor, isMoving);

                // Zeit seit letztem Update
                const timeSinceUpdate = getTimeSinceUpdate(metaData.time_utc);

                // Windgeschwindigkeit in Beaufort konvertieren (falls Wetterdaten vorhanden)
                const windBeaufort = weatherData ? getBeaufortScale(weatherData.windstaerke) : 'Nicht verfügbar';

                // Popup-Inhalt erstellen
                const popupContent = `
                    <div class="ship-popup">
                        <h3 style="margin-top:0; color:#2c5aa0;">${metaData.ShipName}</h3>
                        <div class="status-info">
                            <strong>Status:</strong> ${currentStatus}<br>                            
                            <strong>Geschwindigkeit:</strong> ${posReport.Sog} Knoten<br>
                            <strong>Kurs:</strong> ${posReport.Cog === 360 || posReport.Cog === 999 ? 'Nicht verfügbar' : posReport.Cog + '°'}<br>                       
                            ${weatherData ? `
                            <strong>Wetter:</strong> ${weatherData.wetterzustand}<br>
                            <strong>Lufttemperatur:</strong> ${weatherData.lufttemperatur}°C<br>
                            <strong>Wind:</strong> ${windBeaufort}<br>
                            <strong>Wassertemperatur:</strong> ${weatherData.wassertemperatur} °C<br>
                            <strong>Wellenhöhe:</strong> ${weatherData.wellenhoehe} m<br>
                            ` : '<strong>Wetterdaten:</strong> Nicht verfügbar<br>'}
                            <strong>Letztes Update:</strong> vor ${timeSinceUpdate}<br>
                            <strong>Logbuch (PDF):</strong> <a href="https://github.com/davidoesch/shiptracker/raw/main/nautical_logbook.pdf" download="nautical_logbook.pdf" style="color:#2c5aa0; text-decoration:underline;">PDF herunterladen</a>
                        </div>
                    </div>
                `;

                // Alten Schiffs-Marker entfernen, falls vorhanden
                if (shipMarker) {
                    map.removeLayer(shipMarker);
                }

                // Neuen Schiffs-Marker zur Karte hinzufügen
                shipMarker = L.marker([posReport.Latitude, posReport.Longitude], {
                    icon: shipIcon
                }).addTo(map).bindPopup(popupContent);

                // Popup automatisch öffnen (nur beim ersten Laden und wenn popupzoom aktiviert)
                if (!infoControl && urlParams.popupzoom) {
                    shipMarker.openPopup();
                }

                // Info-Control aktualisieren (immer anzeigen)
                if (infoControl) {
                    map.removeControl(infoControl);
                }

                // Zusätzliche Informationen als permanentes Control hinzufügen
                infoControl = L.control({ position: 'topright' });
                infoControl.onAdd = function (map) {
                    const div = L.DomUtil.create('div', 'status-info');
                    div.innerHTML = `
                        <strong>${metaData.ShipName}</strong><br>
                        Status: ${currentStatus}<br>
                        Geschwindigkeit: ${posReport.Sog} kn<br>
                        ${weatherData ? `
                        Wetter: ${weatherData.wetterzustand}<br>
                        Wind: ${windBeaufort}<br>
                        ` : 'Wetter: Nicht verfügbar<br>'}
                        Update: vor ${timeSinceUpdate}
                    `;
                    div.style.background = 'rgba(255,255,255,0.95)';
                    div.style.padding = '10px';
                    div.style.borderRadius = '5px';
                    div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
                    div.style.fontSize = '12px';
                    return div;
                };
                infoControl.addTo(map);

            } catch (error) {
                console.error('Fehler beim Anzeigen der Schiffsdaten:', error);
            }
        }

        // Karte initialisieren beim Laden der Seite
        initializeMap();

        // Automatische Updates alle 30 Sekunden (lädt neue Daten vom Server)
        setInterval(updateShipData, 30000);
    </script>
</body>

</html>