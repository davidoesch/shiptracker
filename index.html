<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Schiffs-Tracker</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" />
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
        }

        #map {
            height: 100vh;
            width: 100%;
        }

        .ship-popup {
            font-size: 14px;
            line-height: 1.4;
        }

        .ship-popup strong {
            color: #2c5aa0;
        }

        .status-info {
            background: rgba(255, 255, 255, 0.95);
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1000;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .error-message {
            color: red;
            font-weight: bold;
        }

        .maplibregl-popup-content {
            padding: 0 !important;
        }

        .maplibregl-ctrl-top-right {
            top: 10px;
            right: 10px;
        }
    </style>
</head>

<body>
    <div id="loading">Lade Schiffsdaten...</div>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>
    <script>
        // Navigationsstatus-Mapping
        const navigationStatus = {
            0: "Unter Verwendung der Maschine",
            1: "Vor Anker",
            2: "Manövrierunfähig",
            3: "Manövriereingeschränkt",
            4: "Beeinträchtigt durch Tiefgang",
            5: "Festgemacht",
            6: "Auf Grund gelaufen",
            7: "Fischfang",
            8: "Unter Segel",
            9: "Reserviert für HSC",
            10: "Reserviert für WIG",
            11: "Reserviert für zukünftige Nutzung",
            12: "Reserviert für zukünftige Nutzung",
            13: "Reserviert für zukünftige Nutzung",
            14: "AIS-SART aktiv",
            15: "Nicht verfügbar"
        };

        // Funktion zum Berechnen der Zeit seit dem letzten Update
        function getTimeSinceUpdate(utcTimeString) {
            try {
                const updateTime = new Date(utcTimeString);
                const now = new Date();
                const diffMs = now - updateTime;

                const diffSeconds = Math.floor(diffMs / 1000);
                const diffMinutes = Math.floor(diffSeconds / 60);
                const diffHours = Math.floor(diffMinutes / 60);
                const diffDays = Math.floor(diffHours / 24);

                if (diffDays > 0) {
                    return `${diffDays} Tag${diffDays !== 1 ? 'en' : ''}`;
                } else if (diffHours > 0) {
                    return `${diffHours} Stunde${diffHours !== 1 ? 'n' : ''}`;
                } else if (diffMinutes > 0) {
                    return `${diffMinutes} Minute${diffMinutes !== 1 ? 'n' : ''}`;
                } else {
                    return `${diffSeconds} Sekunde${diffSeconds !== 1 ? 'n' : ''}`;
                }
            } catch (error) {
                console.error('Error parsing timestamp:', error);
                return 'unbekannt';
            }
        }

        // Funktion zum Bestimmen der Schiffsfarbe
        function getShipColor(navStatus, cog, sog) {
            if (navStatus !== 1 && cog !== 360 && sog > 0) {
                return '#28a745'; // Grün
            }
            return '#fd7e14'; // Orange
        }

        // Funktion zum Erstellen eines Schiffs-SVG-Icons
        function createShipIcon(cog, color, isMoving) {
            let svgIcon;

            if (!isMoving) {
                svgIcon = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="10" fill="${color}" stroke="#000" stroke-width="2"/>
                    </svg>
                `;

                return L.divIcon({
                    html: svgIcon,
                    className: 'ship-icon',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12],
                    popupAnchor: [0, -12]
                });
            } else if (cog === 370) {
                svgIcon = `
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="10" fill="#28a745" stroke="#000" stroke-width="2"/>
                    </svg>
                `;

                return L.divIcon({
                    html: svgIcon,
                    className: 'ship-icon',
                    iconSize: [24, 24],
                    iconAnchor: [12, 12],
                    popupAnchor: [0, -12]
                });
            } else {
                const rotation = cog === 360 ? 0 : cog;

                svgIcon = `
                    <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="46" height="46" viewBox="0 0 48 48" fill="none" xmlns="http://www.w3.org/2000/svg">
                        <rect width="48" height="48" fill="white" fill-opacity="0.01"/>
                        <g transform="rotate(${rotation - 45} 24 24)" fill="${color}" stroke="#000" stroke-width="1">
                            <path d="M42 6L4 20.1383L24 24.0083L29.0052 44L42 6Z"/>
                        </g>
                    </svg>
                `;

                return L.divIcon({
                    html: svgIcon,
                    className: 'ship-icon',
                    iconSize: [46, 46],
                    iconAnchor: [23, 23],
                    popupAnchor: [0, -23]
                });
            }
        }

        // Funktion zum Laden der Schiffsdaten vom Server
        async function loadShipData() {
            try {
                const response = await fetch('position_report.json');
                if (!response.ok) {
                    throw new Error(`HTTP-Fehler! Status: ${response.status}`);
                }
                const shipData = await response.json();
                return shipData;
            } catch (error) {
                console.error('Fehler beim Laden der Schiffsdaten:', error);
                throw error;
            }
        }

        // Funktion zum Laden der Schiffsspuren
        async function loadShipTracks() {
            try {
                const response = await fetch('ship_tracks.geojson');
                if (!response.ok) {
                    console.warn('Schiffsspuren-Datei nicht gefunden oder nicht erreichbar');
                    return null;
                }
                const tracksData = await response.json();
                return tracksData;
            } catch (error) {
                console.warn('Fehler beim Laden der Schiffsspuren:', error);
                return null;
            }
        }

        // Funktion zum Laden der Schiffspositionen
        async function loadShipPositions() {
            try {
                const response = await fetch('ship_position.geojson');
                if (!response.ok) {
                    console.warn('Schiffspositionen-Datei nicht gefunden oder nicht erreichbar');
                    return null;
                }
                const positionsData = await response.json();
                return positionsData;
            } catch (error) {
                console.warn('Fehler beim Laden der Schiffspositionen:', error);
                return null;
            }
        }

        // Globale Variablen für Karte und Layer
        let map;
        let mapType; // 'leaflet' or 'maplibre'
        let shipMarker;
        let trackLayers = [];
        let infoControl;
        let currentShipData = null;
        let esriImagery, esriLabels, osmPositron;
        let currentBasemap = 'satellite';
        let positionMarkers = [];
        let positionsData = null;

        // Funktion zum Parsen der URL-Parameter
        function getUrlParameters() {
            const params = new URLSearchParams(window.location.search);
            return {
                popupzoom: params.get('popupzoom') !== 'false',
                zoom: parseInt(params.get('zoom')) || 5,
                map: params.get('map') || 'satellite'
            };
        }

        const urlParams = getUrlParameters();

        // Funktion zur Konvertierung von Windgeschwindigkeit (km/h) in Beaufort-Skala
        function getBeaufortScale(windSpeedKmh) {
            if (windSpeedKmh < 1) return "0 (Windstille)";
            if (windSpeedKmh < 5) return "1 (Leiser Zug)";
            if (windSpeedKmh < 11) return "2 (Leichte Brise)";
            if (windSpeedKmh < 19) return "3 (Schwache Brise)";
            if (windSpeedKmh < 28) return "4 (Mäßige Brise)";
            if (windSpeedKmh < 38) return "5 (Frische Brise)";
            if (windSpeedKmh < 49) return "6 (Starker Wind)";
            if (windSpeedKmh < 61) return "7 (Steifer Wind)";
            if (windSpeedKmh < 74) return "8 (Stürmischer Wind)";
            if (windSpeedKmh < 88) return "9 (Sturm)";
            if (windSpeedKmh < 102) return "10 (Schwerer Sturm)";
            if (windSpeedKmh < 117) return "11 (Orkanartiger Sturm)";
            return "12 (Orkan)";
        }

        // Funktion zur Berechnung der Distanz zwischen zwei Koordinaten in Seemeilen
        function calculateDistance(lat1, lon1, lat2, lon2) {
            const R = 3440.065;
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return R * c;
        }

        // Funktion zur Berechnung der Gesamtlänge eines Tracks in Seemeilen
        function calculateTrackLength(coordinates) {
            let totalDistance = 0;
            for (let i = 1; i < coordinates.length; i++) {
                const [lon1, lat1] = coordinates[i - 1];
                const [lon2, lat2] = coordinates[i];
                totalDistance += calculateDistance(lat1, lon1, lat2, lon2);
            }
            return Math.round(totalDistance * 10) / 10;
        }

        // ===== LEAFLET FUNCTIONS =====
        function updatePositionMarkersVisibility() {
            if (!map || mapType !== 'leaflet') return;
            const currentZoom = map.getZoom();
            const shouldShow = currentZoom >= 6 && currentZoom <= 22;

            positionMarkers.forEach(marker => {
                if (shouldShow) {
                    if (!map.hasLayer(marker)) {
                        marker.addTo(map);
                    }
                } else {
                    if (map.hasLayer(marker)) {
                        map.removeLayer(marker);
                    }
                }
            });
        }

        async function loadAndDisplayPositionsLeaflet() {
            if (positionMarkers.length > 0) {
                positionMarkers.forEach(marker => {
                    if (map.hasLayer(marker)) {
                        map.removeLayer(marker);
                    }
                });
                positionMarkers = [];
            }

            try {
                positionsData = await loadShipPositions();

                if (positionsData && positionsData.features) {
                    positionsData.features.forEach(feature => {
                        if (feature.geometry && feature.geometry.type === 'Point') {
                            const coords = feature.geometry.coordinates;
                            const props = feature.properties;

                            const positionIcon = L.divIcon({
                                html: `
                                    <div style="position: relative;">
                                        <svg width="12" height="12" style="display: block;">
                                            <circle cx="6" cy="6" r="5" fill="red" stroke="white" stroke-width="1"/>
                                        </svg>
                                        <div style="position: absolute; left: 14px; top: -4px; white-space: nowrap; font-size: 11px; font-weight: bold; color: red; text-shadow: -1px -1px 0 white, 1px -1px 0 white, -1px 1px 0 white, 1px 1px 0 white;">${props.date}</div>
                                    </div>
                                `,
                                className: 'position-marker',
                                iconSize: [12, 12],
                                iconAnchor: [6, 6]
                            });

                            const marker = L.marker([coords[1], coords[0]], {
                                icon: positionIcon
                            });

                            positionMarkers.push(marker);
                        }
                    });

                    updatePositionMarkersVisibility();
                }
            } catch (error) {
                console.warn('Schiffspositionen konnten nicht geladen werden:', error);
            }
        }

        async function loadAndDisplayTracksLeaflet() {
            if (trackLayers.length > 0) {
                trackLayers.forEach(layer => {
                    if (map.hasLayer(layer)) {
                        map.removeLayer(layer);
                    }
                });
                trackLayers = [];
            }

            try {
                const tracksData = await loadShipTracks();

                if (tracksData && tracksData.features) {
                    tracksData.features.forEach(feature => {
                        if (feature.geometry && feature.geometry.type === 'LineString') {
                            const coordinates = feature.geometry.coordinates.map(coord => [coord[1], coord[0]]);

                            const trackInfo = feature.properties;
                            const startTime = new Date(trackInfo.start_time).toLocaleDateString('de-DE');
                            const endTime = new Date(trackInfo.end_time).toLocaleDateString('de-DE');

                            const trackLength = calculateTrackLength(feature.geometry.coordinates);

                            const trackLine = L.polyline(coordinates, {
                                color: 'red',
                                weight: 3,
                                opacity: 0.8,
                                dashArray: '5, 5'
                            }).addTo(map);

                            const trackPopupContent = `
                                <div class="ship-popup">
                                    <h4 style="margin-top:0; color:#2c5aa0;">Fahrtroute</h4>                                   
                                    <strong>Startzeit:</strong> ${startTime}<br>
                                    <strong>Endzeit:</strong> ${endTime}<br>
                                    <strong>Länge:</strong> ${trackLength} Seemeilen<br>
                                </div>
                            `;

                            trackLine.bindPopup(trackPopupContent);
                            trackLayers.push(trackLine);
                        }
                    });
                }
            } catch (error) {
                console.warn('Schiffsspuren konnten nicht geladen werden:', error);
            }
        }

        async function initializeLeafletMap() {
            mapType = 'leaflet';
            currentShipData = await loadShipData();
            const posReport = currentShipData.PositionReport;

            document.getElementById('loading').style.display = 'none';

            map = L.map('map', {
                zoomControl: urlParams.popupzoom
            }).setView([posReport.Latitude, posReport.Longitude], urlParams.zoom);

            esriImagery = L.tileLayer(
                'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Tiles &copy; Esri, Maxar, Earthstar Geographics',
                maxZoom: 19
            });

            esriLabels = L.tileLayer(
                'https://server.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
                attribution: 'Labels &copy; Esri',
                maxZoom: 19
            });

            osmPositron = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
                subdomains: 'abcd',
                maxZoom: 19
            });

            currentBasemap = urlParams.map;
            if (currentBasemap === 'osm') {
                osmPositron.addTo(map);
            } else {
                esriImagery.addTo(map);
                esriLabels.addTo(map);
            }

            await loadAndDisplayTracksLeaflet();
            await loadAndDisplayPositionsLeaflet();

            map.on('zoomend', updatePositionMarkersVisibility);

            updateShipDisplayLeaflet();
        }

        function updateShipDisplayLeaflet() {
            try {
                if (!currentShipData) return;

                const posReport = currentShipData.PositionReport;
                const metaData = currentShipData.MetaData;
                const weatherData = currentShipData.WeatherData;

                const isMoving = posReport.NavigationalStatus !== 1 && posReport.Cog !== 360 && posReport.Sog > 0;
                const currentStatus = isMoving ? "Unterwegs" : "Gestoppt/Vor Anker";
                const shipColor = getShipColor(posReport.NavigationalStatus, posReport.Cog, posReport.Sog);
                const shipIcon = createShipIcon(posReport.Cog, shipColor, isMoving);
                const timeSinceUpdate = getTimeSinceUpdate(metaData.time_utc);
                const windBeaufort = weatherData ? getBeaufortScale(weatherData.windstaerke) : 'Nicht verfügbar';

                const popupContent = `
                    <div class="ship-popup">
                        <h3 style="margin-top:0; color:#2c5aa0;">${metaData.ShipName}</h3>
                        <div class="status-info">
                            <strong>Status:</strong> ${currentStatus}<br>                            
                            <strong>Geschwindigkeit:</strong> ${posReport.Sog} Knoten<br>
                            <strong>Kurs:</strong> ${posReport.Cog === 360 || posReport.Cog === 999 ? 'Nicht verfügbar' : posReport.Cog + '°'}<br>                       
                            ${weatherData ? `
                            <strong>Wetter:</strong> ${weatherData.wetterzustand}<br>
                            <strong>Lufttemperatur:</strong> ${weatherData.lufttemperatur}°C<br>
                            <strong>Wind:</strong> ${windBeaufort}<br>
                            <strong>Wassertemperatur:</strong> ${weatherData.wassertemperatur} °C<br>
                            <strong>Wellenhöhe:</strong> ${weatherData.wellenhoehe} m<br>
                            ` : '<strong>Wetterdaten:</strong> Nicht verfügbar<br>'}
                            <strong>Letztes Update:</strong> vor ${timeSinceUpdate}<br>
                            <strong>Logbuch (PDF):</strong> <a href="https://github.com/davidoesch/shiptracker/raw/main/nautical_logbook.pdf" download="nautical_logbook.pdf" style="color:#2c5aa0; text-decoration:underline;">PDF herunterladen</a>
                        </div>
                    </div>
                `;

                if (shipMarker) {
                    map.removeLayer(shipMarker);
                }

                shipMarker = L.marker([posReport.Latitude, posReport.Longitude], {
                    icon: shipIcon
                }).addTo(map).bindPopup(popupContent);

                if (!infoControl && urlParams.popupzoom) {
                    shipMarker.openPopup();
                }

                if (infoControl) {
                    map.removeControl(infoControl);
                }

                infoControl = L.control({ position: 'topright' });
                infoControl.onAdd = function (map) {
                    const div = L.DomUtil.create('div', 'status-info');
                    div.innerHTML = `
                        <strong>${metaData.ShipName}</strong><br>
                        Status: ${currentStatus}<br>
                        Geschwindigkeit: ${posReport.Sog} kn<br>
                        ${weatherData ? `
                        Wetter: ${weatherData.wetterzustand}<br>
                        Wind: ${windBeaufort}<br>
                        ` : 'Wetter: Nicht verfügbar<br>'}
                        Update: vor ${timeSinceUpdate}
                    `;
                    div.style.background = 'rgba(255,255,255,0.95)';
                    div.style.padding = '10px';
                    div.style.borderRadius = '5px';
                    div.style.boxShadow = '0 2px 5px rgba(0,0,0,0.2)';
                    div.style.fontSize = '12px';
                    return div;
                };
                infoControl.addTo(map);

            } catch (error) {
                console.error('Fehler beim Anzeigen der Schiffsdaten:', error);
            }
        }

        // ===== MAPLIBRE FUNCTIONS =====
        async function initializeMapLibreMap() {
            mapType = 'maplibre';
            currentShipData = await loadShipData();
            const posReport = currentShipData.PositionReport;

            document.getElementById('loading').style.display = 'none';

            // Try to load custom style, fallback to default
            let styleUrl = 'style_bw.json';
            try {
                const styleCheck = await fetch(styleUrl);
                if (!styleCheck.ok) {
                    console.warn('Custom style not found, using default OpenFreeMap style');
                    styleUrl = 'https://tiles.openfreemap.org/styles/liberty';
                }
            } catch (error) {
                console.warn('Error loading custom style:', error);
                styleUrl = 'https://tiles.openfreemap.org/styles/liberty';
            }

            map = new maplibregl.Map({
                container: 'map',
                style: styleUrl,
                center: [posReport.Longitude, posReport.Latitude],
                zoom: urlParams.zoom,
                attributionControl: true
            });

            if (!urlParams.popupzoom) {
                map.addControl(new maplibregl.NavigationControl(), 'top-right');
            }

            map.on('load', async () => {
                await loadAndDisplayTracksMapLibre();
                await loadAndDisplayPositionsMapLibre();
                updateShipDisplayMapLibre();
            });

            map.on('zoom', () => {
                updatePositionMarkersVisibilityMapLibre();
            });
        }

        async function loadAndDisplayTracksMapLibre() {
            try {
                const tracksData = await loadShipTracks();

                if (tracksData && tracksData.features) {
                    // Add source
                    if (!map.getSource('ship-tracks')) {
                        map.addSource('ship-tracks', {
                            type: 'geojson',
                            data: tracksData
                        });

                        // Add line layer
                        map.addLayer({
                            id: 'ship-tracks-layer',
                            type: 'line',
                            source: 'ship-tracks',
                            paint: {
                                'line-color': '#ff0000',
                                'line-width': 3,
                                'line-opacity': 0.8,
                                'line-dasharray': [2, 2]
                            }
                        });

                        // Add click handler for popups
                        map.on('click', 'ship-tracks-layer', (e) => {
                            const feature = e.features[0];
                            const props = feature.properties;
                            const startTime = new Date(props.start_time).toLocaleDateString('de-DE');
                            const endTime = new Date(props.end_time).toLocaleDateString('de-DE');
                            const trackLength = calculateTrackLength(feature.geometry.coordinates);

                            new maplibregl.Popup()
                                .setLngLat(e.lngLat)
                                .setHTML(`
                                    <div class="ship-popup" style="padding: 10px;">
                                        <h4 style="margin-top:0; color:#2c5aa0;">Fahrtroute</h4>                                   
                                        <strong>Startzeit:</strong> ${startTime}<br>
                                        <strong>Endzeit:</strong> ${endTime}<br>
                                        <strong>Länge:</strong> ${trackLength} Seemeilen<br>
                                    </div>
                                `)
                                .addTo(map);
                        });

                        map.on('mouseenter', 'ship-tracks-layer', () => {
                            map.getCanvas().style.cursor = 'pointer';
                        });

                        map.on('mouseleave', 'ship-tracks-layer', () => {
                            map.getCanvas().style.cursor = '';
                        });
                    }
                }
            } catch (error) {
                console.warn('Schiffsspuren konnten nicht geladen werden:', error);
            }
        }

        async function loadAndDisplayPositionsMapLibre() {
            try {
                positionsData = await loadShipPositions();

                if (positionsData && positionsData.features) {
                    if (!map.getSource('ship-positions')) {
                        map.addSource('ship-positions', {
                            type: 'geojson',
                            data: positionsData
                        });

                        map.addLayer({
                            id: 'ship-positions-layer',
                            type: 'circle',
                            source: 'ship-positions',
                            paint: {
                                'circle-radius': 5,
                                'circle-color': '#ff0000',
                                'circle-stroke-width': 1,
                                'circle-stroke-color': '#ffffff'
                            },
                            minzoom: 6,
                            maxzoom: 22
                        });

                        map.addLayer({
                            id: 'ship-positions-labels',
                            type: 'symbol',
                            source: 'ship-positions',
                            layout: {
                                'text-field': ['get', 'date'],
                                'text-font': ['Open Sans Bold', 'Arial Unicode MS Bold'],
                                'text-size': 11,
                                'text-offset': [1, 0],
                                'text-anchor': 'left'
                            },
                            paint: {
                                'text-color': '#ff0000',
                                'text-halo-color': '#ffffff',
                                'text-halo-width': 2
                            },
                            minzoom: 6,
                            maxzoom: 22
                        });
                    }
                }
            } catch (error) {
                console.warn('Schiffspositionen konnten nicht geladen werden:', error);
            }
        }

        function updatePositionMarkersVisibilityMapLibre() {
            // MapLibre handles visibility via minzoom/maxzoom in layer definition
        }

        function updateShipDisplayMapLibre() {
            try {
                if (!currentShipData) return;

                const posReport = currentShipData.PositionReport;
                const metaData = currentShipData.MetaData;
                const weatherData = currentShipData.WeatherData;

                const isMoving = posReport.NavigationalStatus !== 1 && posReport.Cog !== 360 && posReport.Sog > 0;
                const currentStatus = isMoving ? "Unterwegs" : "Gestoppt/Vor Anker";
                const shipColor = getShipColor(posReport.NavigationalStatus, posReport.Cog, posReport.Sog);
                const timeSinceUpdate = getTimeSinceUpdate(metaData.time_utc);
                const windBeaufort = weatherData ? getBeaufortScale(weatherData.windstaerke) : 'Nicht verfügbar';

                // Create ship icon HTML
                let iconHtml;
                if (!isMoving) {
                    iconHtml = `<svg width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="${shipColor}" stroke="#000" stroke-width="2"/></svg>`;
                } else if (posReport.Cog === 370) {
                    iconHtml = `<svg width="24" height="24" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="#28a745" stroke="#000" stroke-width="2"/></svg>`;
                } else {
                    const rotation = posReport.Cog === 360 ? 0 : posReport.Cog;
                    iconHtml = `<svg width="46" height="46" viewBox="0 0 48 48" fill="none"><rect width="48" height="48" fill="white" fill-opacity="0.01"/><g transform="rotate(${rotation - 45} 24 24)" fill="${shipColor}" stroke="#000" stroke-width="1"><path d="M42 6L4 20.1383L24 24.0083L29.0052 44L42 6Z"/></g></svg>`;
                }

                // Create marker element
                const el = document.createElement('div');
                el.innerHTML = iconHtml;
                el.style.cursor = 'pointer';

                const popupContent = `
                    <div class="ship-popup" style="padding: 10px;">
                        <h3 style="margin-top:0; color:#2c5aa0;">${metaData.ShipName}</h3>
                        <div class="status-info">
                            <strong>Status:</strong> ${currentStatus}<br>                            
                            <strong>Geschwindigkeit:</strong> ${posReport.Sog} Knoten<br>
                            <strong>Kurs:</strong> ${posReport.Cog === 360 || posReport.Cog === 999 ? 'Nicht verfügbar' : posReport.Cog + '°'}<br>                       
                            ${weatherData ? `
                            <strong>Wetter:</strong> ${weatherData.wetterzustand}<br>
                            <strong>Lufttemperatur:</strong> ${weatherData.lufttemperatur}°C<br>
                            <strong>Wind:</strong> ${windBeaufort}<br>
                            <strong>Wassertemperatur:</strong> ${weatherData.wassertemperatur} °C<br>
                            <strong>Wellenhöhe:</strong> ${weatherData.wellenhoehe} m<br>
                            ` : '<strong>Wetterdaten:</strong> Nicht verfügbar<br>'}
                            <strong>Letztes Update:</strong> vor ${timeSinceUpdate}<br>
                            <strong>Logbuch (PDF):</strong> <a href="https://github.com/davidoesch/shiptracker/raw/main/nautical_logbook.pdf" download="nautical_logbook.pdf" style="color:#2c5aa0; text-decoration:underline;">PDF herunterladen</a>
                        </div>
                    </div>
                `;

                shipMarker = new maplibregl.Marker({ element: el })
                    .setLngLat([posReport.Longitude, posReport.Latitude])
                    .setPopup(new maplibregl.Popup({ offset: 25 }).setHTML(popupContent))
                    .addTo(map);

                if (urlParams.popupzoom) {
                    shipMarker.togglePopup();
                }

                // Add info control
                const infoDiv = document.createElement('div');
                infoDiv.className = 'maplibregl-ctrl maplibregl-ctrl-group';
                infoDiv.innerHTML = `
                    <div class="status-info">
                        <strong>${metaData.ShipName}</strong><br>
                        Status: ${currentStatus}<br>
                        Geschwindigkeit: ${posReport.Sog} kn<br>
                        ${weatherData ? `
                        Wetter: ${weatherData.wetterzustand}<br>
                        Wind: ${windBeaufort}<br>
                        ` : 'Wetter: Nicht verfügbar<br>'}
                        Update: vor ${timeSinceUpdate}
                    </div>
                `;

                const topRightControls = document.querySelector('.maplibregl-ctrl-top-right');
                if (topRightControls) {
                    topRightControls.appendChild(infoDiv);
                }

            } catch (error) {
                console.error('Fehler beim Anzeigen der Schiffsdaten:', error);
            }
        }

        // ===== MAIN INITIALIZATION =====
        async function initializeMap() {
            try {
                if (urlParams.map === 'blackwhite') {
                    await initializeMapLibreMap();
                } else {
                    await initializeLeafletMap();
                }
            } catch (error) {
                console.error('Fehler beim Initialisieren der Karte:', error);
                document.getElementById('loading').innerHTML = `
                    <div class="error-message">
                        Fehler beim Laden der Schiffsdaten:<br>
                        ${error.message}<br><br>
                        Bitte prüfen Sie, ob die Datei 'position_report.json' auf dem Server verfügbar ist.
                    </div>
                `;
            }
        }

        async function updateShipData() {
            try {
                if (mapType === 'leaflet') {
                    await loadAndDisplayTracksLeaflet();
                    await loadAndDisplayPositionsLeaflet();
                    currentShipData = await loadShipData();
                    updateShipDisplayLeaflet();
                } else {
                    // For MapLibre, update sources
                    currentShipData = await loadShipData();
                    
                    const tracksData = await loadShipTracks();
                    if (tracksData && map.getSource('ship-tracks')) {
                        map.getSource('ship-tracks').setData(tracksData);
                    }
                    
                    const positionsData = await loadShipPositions();
                    if (positionsData && map.getSource('ship-positions')) {
                        map.getSource('ship-positions').setData(positionsData);
                    }
                    
                    if (shipMarker) {
                        shipMarker.remove();
                    }
                    updateShipDisplayMapLibre();
                }
            } catch (error) {
                console.error('Fehler beim Aktualisieren der Schiffsdaten:', error);
            }
        }

        initializeMap();
        setInterval(updateShipData, 30000);